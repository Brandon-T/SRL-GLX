const
  VK_ENTER = 13;

var
  OnTerminateProcs: TStringArray;

type TCardinalArray = array of Cardinal;

type Timer = record
  Time: Int64;
end;

Procedure Timer.Start;
Begin
  Time := GetSystemTime;
End;

Procedure Timer.Reset;
Begin
  Time := 0;
End;

Function Timer.TimeElapsed: Integer;
Begin
  Result := GetSystemTime - Time;
End;

Procedure TypeByte(B: Byte);
Begin
  {$IFDEF SMART}
  If (B = 13) then
    B:= 10;
  {$ENDIF}
  KeyDown(B);
  Wait(10 + Random(50));
  KeyUp(B);
End;

Procedure TypeSend(Text: String; Send: Boolean = True);
var
  I: Integer;
Begin
  For I := 1 to Length(Text) do
  Begin
    {$IFDEF SIMBAMAJOR980}
    SendKeys(Text[i], 40 + Random(40));
    {$ELSE}
    SendKeys(Text[i], 30 + Random(30), 30 + Random(30));
    {$ENDIF}
    Wait(20 + Random(40));
  End;

  If (Send) Then
    TypeByte(VK_ENTER);
End;

Procedure Delete(Ptr: Pointer; var Pointers: Array of Pointer); overload;
var
  I, J: Integer = 0;
  Ptrs: Array of Pointer;
begin
  SetLength(Ptrs, Length(Pointers));
  For I := 0 To High(Pointers) do
    if (Pointers[I] <> Ptr) then
    begin
      Ptrs[J] := Pointers[I];
      Inc(J);
    end;
  SetLength(Ptrs, J);
  Pointers := Ptrs;
end;

Function TIntegerArray.Contains(Value: Integer): Boolean;
var
  I: Integer;
Begin
  For I := 0 To High(Self) Do
    if (Self[I] = Value) then
    begin
      Result := True;
      Exit;
    end;
  Result := False;
End;

Function TCardinalArray.Contains(Value: Cardinal): Boolean;
var
  I: Integer;
Begin
  For I := 0 To High(Self) Do
    if (Self[I] = Value) then
    begin
      Result := True;
      Exit;
    end;
  Result := False;
End;

Function TStringArray.Contains(Value: String; CaseSensitive: Boolean = True): Boolean;
var
  I: Integer;
Begin
  If (CaseSensitive) then
    Value := LowerCase(Value);

  For I := 0 To High(Self) Do
    if (CaseSensitive) then
    begin
      if (LowerCase(Self[I]) = Value) then
      begin
        Result := True;
        Exit;
      end;
    end else
      if (Self[I] = Value) then
      begin
        Result := True;
        Exit;
      end;
  Result := False;
End;

procedure TerminateScript; override;
var
  I: Integer;
begin
  For I := 0 to High(OnTerminateProcs) Do
  begin
    VariantInvoke(OnTerminateProcs[I]);
  end;
  inherited();
end;

procedure AddOnTerminate(const Proc: string);
var
  I, L: Integer;
begin
  For I := 0 To High(OnTerminateProcs) Do
    if (OnTerminateProcs.Contains(Proc, False)) then
      Exit;

  L := Length(OnTerminateProcs);
  SetLength(OnTerminateProcs, L + 1);
  OnTerminateProcs[L] := Proc;
end;

procedure AddOnTerminate(const Procs: TStringArray); overload;
var
  I: Integer;
begin
  For I := 0 To High(OnTerminateProcs) Do
    AddOnTerminate(Procs[I]);
end;
