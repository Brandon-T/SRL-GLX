{$include_once GLX/GLXCore.Simba}
{$include_once GLX/Cache.Simba}

Function GL_MouseHoverBounds: TBox;
var
  UL, BR: glTextureArray;
Begin
  UL := glGetTextures(8814);
  BR := glGetTextures(8936);
  If ((Length(UL) > 0) and (Length(BR) > 0)) then
    Result := IntToBox(UL[0].Bounds.X1, UL[0].Bounds.Y1, BR[High(BR)].Bounds.X2, BR[High(BR)].Bounds.Y2);
End;

Function GL_InterfaceUpTextBounds: TBox;
var
  UL, BR: glTextureArray;
Begin
  UL := glGetTextures(8814);
  BR := glGetTextures(8936);
  If ((Length(UL) >= 2) and (Length(BR) >= 2)) then
    Result := IntToBox(UL[High(UL)].Bounds.X1, UL[High(UL)].Bounds.Y1, BR[High(BR)].Bounds.X2, BR[High(BR)].Bounds.Y2);
End;

Function GL_UptextBounds: TBox;
var
  UL, BR: glTextureArray;
Begin
  UL := glGetTextures(8814);
  BR := glGetTextures(8936);
  If ((Length(UL) >= 2) and (Length(BR) >= 2)) Then
  Begin
    If (UL[0].X < UL[High(UL)].X) Then
      Result := IntToBox(UL[0].Bounds.X1, UL[0].Bounds.Y1, BR[High(BR)].Bounds.X2, BR[High(BR)].Bounds.Y2)
    Else
      Result := IntToBox(UL[High(UL)].Bounds.X1, UL[High(UL)].Bounds.Y1, BR[High(BR)].Bounds.X2, BR[High(BR)].Bounds.Y2)
  End;
End;

Function GL_GetMouseUpText: TStringArray;
var
  glChars: glCharArray;
Begin
  glChars := glGetChars(GL_UptextBounds);
  If (Length(glChars) > 0) then
    Result := glCharsToText(glChars, 5, 5);
End;

Function GL_IsMouseUpText(Text: String): Boolean;
Begin
  Result := Pos(Text, Implode('', GL_GetMouseUpText)) > 0;
End;

Function GL_IsMouseUpText(Text: TStringArray): Boolean; overload;
var
  I, H: Integer;
  Uptext: String;
Begin
  Uptext := Implode('', GL_GetMouseUpText);
  H := High(Text);
  For I := 0 To H Do
    If (Pos(Text[I], UpText) > 0) Then
    Begin
      Result := True;
      Exit;
    End;
End;

Function GL_ChatBounds: TBox;
var
  I, J: Integer;
  S, T: glTextureArray;
Begin
  If (Not GL_LoggedIn) Then Exit;
  If (UseSysCache) Then
  Begin
    I := SysCache.Contains(CACHE_CHAT);
    if (I <> -1) Then
    Begin
      Result := SysCache[I].Area;
      Exit;
    End;
  End;

  T := glGetTextures(3786240); //Chatbox texture.
  S := glGetTextures(24990);   //ChatBubble.
  If (Length(T) > 0 and Length(S) > 0) then
    For I := 0 To High(T) Do
      For J := 0 To High(S) Do
        If (PointInBox(Point(S[J].X, S[J].Y), T[I].Bounds)) then
        begin
          Result := T[I].Bounds;
          If (UseSysCache) Then
            SysCache.CacheChat(Result);
          Exit;
        end;
End;

Function GL_FindNPCChatText(Texts: TStringArray; Action: Integer): Boolean;
var
  B: TBox;
  TP: TPoint;
  I, J: Integer;
  Text: glTextArray;
  Options: glTextureArray;
Begin
  B := GL_ChatBounds;
  Options := glGetTextures(52107, B);
  Insert(glGetTextures(52825, B), Options);
  If (Length(Options) < 2) Then Exit;
  Text := glCharsToTexts(glGetChars(B), 4, 5);

  TP := Point(-1, -1);
  For I := 0 To High(Text) Do
    For J := 0 To High(Texts) Do
      If (Pos(Texts[J], Text[I].Text) > 0) then
      begin
        TP := MiddleBox(Text[I].Bounds);
        break;
      end;

  For I := 0 To High(Options) Do
  Begin
    B.X1 := Options[I].Bounds.X1;
    B.Y1 := Options[I].Bounds.Y1;
    B.X2 := Options[I + 1].Bounds.X2;
    B.Y2 := Options[I + 1].Bounds.Y2;
    Inc(I);

    If (PointInBox(TP, B)) then
    Begin
      TP := MiddleBox(B);
      Break;
    End;
  End;

  If (TP.X <> -1 And TP.Y <> -1) Then
  Begin
    Case Action Of
      MOUSE_MOVE:  Mouse(TP.X, TP.Y, 6, 3);
      MOUSE_LEFT:  Mouse(TP.X, TP.Y, 6, 3, MOUSE_LEFT);
      MOUSE_RIGHT: Mouse(TP.X, TP.Y, 6, 3, MOUSE_RIGHT);
    End;
    Result := True;
  End;
End;

Function GL_FindNPCChatText(Text: String; Action: Integer): Boolean; overload;
Begin
  Result := GL_FindNPCChatText([Text], Action);
End;

Function GL_GetChooseOptions(var MenuBounds: TBox): glTextArray;
var
  TL, LR: glTextureArray;
Begin
  TL := glGetTextures(6120, 5921370, 5);
  LR := glGetTextures(8925, 4079167, 5);

  If ((Length(TL) < 1) Or (Length(LR) < 1)) Then Exit;
  MenuBounds := IntToBox(TL[0].Bounds.X1, TL[0].Bounds.Y2, LR[1].Bounds.X2, LR[1].Bounds.Y2);
  Result := glCharsToTexts(glGetChars(MenuBounds), 4, 7);
End;

Function GL_ChooseOption(Texts: TStringArray; Action: Integer): Boolean;
var
  MP: TPoint;
  Bounds: TBox;
  MenuBounds: TBox;
  I, II: Integer;
  Options: glTextArray;
Begin
  Result := False;
  Options := GL_GetChooseOptions(MenuBounds);
  If (Length(Options) < 1) Then Exit;

  For I := 0 To High(Texts) Do
    For II := High(Options) DownTo 0 Do
    Begin
      If (Pos(Texts[I], Options[II].Text) > 0) Then
      Begin
        Result := True;
        Bounds := Options[II].Bounds;
        GetMousePos(MP.X, MP.Y);

        Case Action Of
          MOUSE_LEFT:
                       If PointInBox(MP, Bounds) Then
                         ClickMouse(MOUSE_LEFT)
                       Else
                         MouseBox(Bounds, MOUSE_LEFT);

          MOUSE_MOVE:  If (Not PointInBox(MP, Bounds)) Then
                         MouseBox(Bounds, MOUSE_MOVE);

          MOUSE_NIL:   Begin End;

          Else
            Writeln('CLICK LEFT IS AN INVALID OPTION');
        End;
        Exit;
      End;
    End;

  If (Action <> MOUSE_NIL) Then
  Begin
    I := Max(MenuBounds.X1 + RandomRange(15, 50), 0);
    If (I = 0) Then
      I := MenuBounds.X2 + RandomRange(10, 50);
    Mouse(I, Max(MenuBounds.Y1 - RandomRange(40, 50), 0), 5, 5);
  End;
End;

Function GL_ChooseOption(Options: TStringArray): Boolean; overload;
Begin
  Result := GL_ChooseOption(Options, MOUSE_LEFT);
End;

Function GL_ChooseOption(Option: String): Boolean; overload;
Begin
  Result := GL_ChooseOption([Option], MOUSE_LEFT);
End;

Function GL_OptionsExist(Options: TStringArray; MoveMouse: Boolean): Boolean;
Begin
  If MoveMouse Then
    Result := GL_ChooseOption(Options, MOUSE_MOVE)
  Else
    Result := GL_ChooseOption(Options, MOUSE_NIL);
End;
